
@inproceedings{legunsen_techniques_2019,
	location = {Xi'an, China},
	title = {Techniques for Evolution-Aware Runtime Verification},
	isbn = {978-1-72811-736-2},
	url = {https://ieeexplore.ieee.org/document/8730172/},
	doi = {10.1109/ICST.2019.00037},
	abstract = {Runtime VeriÔ¨Åcation ({RV}) can help Ô¨Ånd bugs by monitoring program executions against formal properties. Developers should ideally use {RV} whenever they run tests, to Ô¨Ånd more bugs earlier. Despite tremendous research progress, {RV} still incurs high overhead in (1) machine time to monitor properties and (2) developer time to wait for and inspect violations from test executions that do not satisfy the properties. Moreover, all prior {RV} techniques consider only one program version and wastefully re-monitor unaffected properties and code as software evolves.},
	eventtitle = {2019 12th {IEEE} Conference on Software Testing, Validation and Verification ({ICST})},
	pages = {300--311},
	booktitle = {2019 12th {IEEE} Conference on Software Testing, Validation and Verification ({ICST})},
	publisher = {{IEEE}},
	author = {Legunsen, Owolabi and Zhang, Yi and Hadzi-Tanovic, Milica and Rosu, Grigore and Marinov, Darko},
	urldate = {2023-03-04},
	date = {2019-04},
	langid = {english},
	file = {Legunsen et al. - 2019 - Techniques for Evolution-Aware Runtime Verificatio.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\U33IUY8M\\Legunsen et al. - 2019 - Techniques for Evolution-Aware Runtime Verificatio.pdf:application/pdf},
}

@inproceedings{legunsen_evolution-aware_2015,
	location = {Florence, Italy},
	title = {Evolution-Aware Monitoring-Oriented Programming},
	isbn = {978-1-4799-1934-5},
	url = {http://ieeexplore.ieee.org/document/7203026/},
	doi = {10.1109/ICSE.2015.206},
	abstract = {Monitoring-Oriented Programming ({MOP}) helps develop more reliable software by means of monitoring against formal speciÔ¨Åcations. While {MOP} showed promising results, all prior research has focused on checking a single version of software. We propose to extend {MOP} to support multiple software versions and thus be more relevant in the context of rapid software evolution. Our approach, called {eMOP}, is inspired by regression test selection‚Äîa well studied, evolution-centered technique. The key idea in {eMOP} is to monitor only the parts of code that changed between versions. We illustrate {eMOP} by means of a running example, and show the results of preliminary experiments. {eMOP} opens up a new line of research on {MOP}‚Äîit can signiÔ¨Åcantly improve usability and performance when applied across multiple versions of software and is complementary to algorithmic {MOP} advances on a single version.},
	eventtitle = {2015 {IEEE}/{ACM} 37th {IEEE} International Conference on Software Engineering ({ICSE})},
	pages = {615--618},
	booktitle = {2015 {IEEE}/{ACM} 37th {IEEE} International Conference on Software Engineering},
	publisher = {{IEEE}},
	author = {Legunsen, Owolabi and Marinov, Darko and Rosu, Grigore},
	urldate = {2023-03-04},
	date = {2015-05},
	langid = {english},
	file = {Legunsen et al. - 2015 - Evolution-Aware Monitoring-Oriented Programming.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\XR9GKDUF\\Legunsen et al. - 2015 - Evolution-Aware Monitoring-Oriented Programming.pdf:application/pdf},
}

@incollection{bobaru_generating_2011,
	location = {Berlin, Heidelberg},
	title = {Generating Data Race Witnesses by an {SMT}-Based Analysis},
	volume = {6617},
	isbn = {978-3-642-20397-8 978-3-642-20398-5},
	url = {http://link.springer.com/10.1007/978-3-642-20398-5_23},
	abstract = {Data race is one of the most dangerous errors in multithreaded programming, and despite intensive studies, it remains a notorious cause of failures in concurrent systems. Detecting data races, statically or dynamically, is already a hard problem, and yet it is even harder for a programmer to decide whether or how a reported data race can appear in the actual program execution. In this paper we propose an algorithm for generating debugging aid information called witnesses, which are concrete thread schedules that can deterministically trigger the data races. More speciÔ¨Åcally, given a concrete execution trace of the program, which may be non-erroneous but have triggered a warning in Eraser-style data race detectors, we use a symbolic analysis based on {SMT} solvers to search for such a witness among alternative interleavings of events of that trace. Our symbolic analysis precisely encodes the sequential consistency semantics using a scalable predictive model to ensure that the reported witness is always feasible.},
	pages = {313--327},
	booktitle = {{NASA} Formal Methods},
	publisher = {Springer Berlin Heidelberg},
	author = {Said, Mahmoud and Wang, Chao and Yang, Zijiang and Sakallah, Karem},
	editor = {Bobaru, Mihaela and Havelund, Klaus and Holzmann, Gerard J. and Joshi, Rajeev},
	urldate = {2023-03-04},
	date = {2011},
	langid = {english},
	doi = {10.1007/978-3-642-20398-5_23},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Said et al. - 2011 - Generating Data Race Witnesses by an SMT-Based Ana.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\6IY6KTP3\\Said et al. - 2011 - Generating Data Race Witnesses by an SMT-Based Ana.pdf:application/pdf},
}

@inproceedings{huang_maximal_2014,
	location = {Edinburgh United Kingdom},
	title = {Maximal sound predictive race detection with control flow abstraction},
	isbn = {978-1-4503-2784-8},
	url = {https://dl.acm.org/doi/10.1145/2594291.2594315},
	doi = {10.1145/2594291.2594315},
	abstract = {Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control Ô¨Çow information into the execution model, which increases the space of the causal model permitted by classical happens-before or causally-precedes based detectors. By encoding the control Ô¨Çow and a minimal set of feasibility constraints as a group of Ô¨Årst-order logic formulae, we formulate race detection as a constraint solving problem. Moreover, we formally prove that our formulation achieves the maximal possible detection capability for any sound dynamic race detector with respect to the same input trace under the sequential consistency memory model. We demonstrate via extensive experimentation that our technique detects more races than the other state-of-the-art sound race detection techniques, and that it is scalable to executions of real world concurrent applications with tens of millions of critical events. These experiments also revealed several previously unknown races in real systems (e.g., Eclipse) that have been conÔ¨Årmed or Ô¨Åxed by the developers. Our tool is also adopted by Eclipse developers.},
	eventtitle = {{PLDI} '14: {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	pages = {337--348},
	booktitle = {Proceedings of the 35th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Huang, Jeff and Meredith, Patrick O'Neil and Rosu, Grigore},
	urldate = {2023-06-17},
	date = {2014-06-09},
	langid = {english},
	file = {Huang et al. - 2014 - Maximal sound predictive race detection with contr.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\SRHTF7YP\\huang-meredith-rosu-2014-pldi.pdf:application/pdf},
}

@article{smaragdakis_sound_nodate,
	title = {Sound Predictive Race Detection in Polynomial Time},
	abstract = {Data races are among the most reliable indicators of programming errors in concurrent software. For at least two decades, Lamport‚Äôs happens-before ({HB}) relation has served as the standard test for detecting races‚Äîother techniques, such as lockset-based approaches, fail to be sound, as they may falsely warn of races. This work introduces a new relation, causally-precedes ({CP}), which generalizes happens-before to observe more races without sacriÔ¨Åcing soundness. Intuitively, {CP} tries to capture the concept of happens-before ordered events that must occur in the observed order for the program to observe the same values. What distinguishes {CP} from past predictive race detection approaches (which also generalize an observed execution to detect races in other plausible executions) is that {CP}-based race detection is both sound and of polynomial complexity.},
	author = {Smaragdakis, Yannis and Evans, Jacob M and Sadowski, Caitlin and Yi, Jaeheon and Flanagan, Cormac},
	langid = {english},
	file = {Smaragdakis et al. - Sound Predictive Race Detection in Polynomial Time.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\QP9SLYWM\\Smaragdakis et al. - Sound Predictive Race Detection in Polynomial Time.pdf:application/pdf},
}

@incollection{hutchison_maximal_2013,
	location = {Berlin, Heidelberg},
	title = {Maximal Causal Models for Sequentially Consistent Systems},
	volume = {7687},
	isbn = {978-3-642-35631-5 978-3-642-35632-2},
	url = {http://link.springer.com/10.1007/978-3-642-35632-2_16},
	abstract = {This paper shows that it is possible to build a maximal and sound causal model for concurrent computations from a given execution trace. It is sound, in the sense that any program which can generate a trace can also generate all traces in its causal model. It is maximal (among sound models), in the sense that by extending the causal model of an observed trace with a new trace, the model becomes unsound: there exists a program generating the original trace which cannot generate the newly introduced trace. Thus, the maximal sound model has the property that it comprises all traces which all programs that can generate the original trace can also generate. The existence of such a model is of great theoretical value as it can be used to prove the soundness of non-maximal, and thus smaller, causal models.},
	pages = {136--150},
	booktitle = {Runtime Verification},
	publisher = {Springer Berlin Heidelberg},
	author = {≈ûerbƒÉnu≈£ƒÉ, Traian Florin and Chen, Feng and Ro≈üu, Grigore},
	editor = {Qadeer, Shaz and Tasiran, Serdar},
	editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2023-06-19},
	date = {2013},
	langid = {english},
	doi = {10.1007/978-3-642-35632-2_16},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {≈ûerbƒÉnu≈£ƒÉ et al. - 2013 - Maximal Causal Models for Sequentially Consistent .pdf:C\:\\Users\\zhyda\\Zotero\\storage\\797C44EJ\\≈ûerbƒÉnu≈£ƒÉ et al. - 2013 - Maximal Causal Models for Sequentially Consistent .pdf:application/pdf},
}

@inproceedings{kini_dynamic_2017,
	location = {Barcelona Spain},
	title = {Dynamic race prediction in linear time},
	isbn = {978-1-4503-4988-8},
	url = {https://dl.acm.org/doi/10.1145/3062341.3062374},
	doi = {10.1145/3062341.3062374},
	abstract = {Writing reliable concurrent software remains a huge challenge for today‚Äôs programmers. Programmers rarely reason about their code by explicitly considering different possible inter-leavings of its execution. We consider the problem of detecting data races from individual executions in a sound manner. The classical approach to solving this problem has been to use Lamport‚Äôs happens-before ({HB}) relation. Until now {HB} remains the only approach that runs in linear time. Previous efforts in improving over {HB} such as causallyprecedes ({CP}) and maximal causal models fall short due to the fact that they are not implementable efÔ¨Åciently and hence have to compromise on their race detecting ability by limiting their techniques to bounded sized fragments of the execution. We present a new relation weak-causally-precedes ({WCP}) that is provably better than {CP} in terms of being able to detect more races, while still remaining sound. Moreover, it admits a linear time algorithm which works on the entire execution without having to fragment it.},
	eventtitle = {{PLDI} '17: {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	pages = {157--170},
	booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
	urldate = {2023-06-23},
	date = {2017-06-14},
	langid = {english},
	file = {Kini et al. - 2017 - Dynamic race prediction in linear time.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\WZ3UZKS2\\Kini et al. - 2017 - Dynamic race prediction in linear time.pdf:application/pdf},
}

@article{mathur_what_2018,
	title = {What happens-after the first race? enhancing the predictive power of happens-before based dynamic race detection},
	volume = {2},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3276515},
	doi = {10.1145/3276515},
	shorttitle = {What happens-after the first race?},
	abstract = {Dynamic race detection is the problem of determining if an observed program execution reveals the presence of a data race in a program. The classical approach to solving this problem is to detect if there is a pair of conflicting memory accesses that are unordered by Lamport‚Äôs happens-before ({HB}) relation. {HB} based race detection is known to not report false positives, i.e., it is sound. However, the soundness guarantee of {HB} only promises that the first pair of unordered, conflicting events is a
              schedulable
              data race. That is, there can be pairs of {HB}-unordered conflicting data accesses that are not schedulable races because there is no reordering of the events of the execution, where the events in race can be executed immediately after each other. We introduce a new partial order, called schedulable happens-before ({SHB}) that exactly characterizes the pairs of schedulable data races ‚Äî every pair of conflicting data accesses that are identified by {SHB} can be scheduled, and every {HB}-race that can be scheduled is identified by {SHB}. Thus, the {SHB} partial order is truly sound. We present a linear time, vector clock algorithm to detect schedulable races using {SHB}. Our experiments demonstrate the value of our algorithm for dynamic race detection ‚Äî {SHB} incurs only little performance overhead and can scale to executions from real-world software applications without compromising soundness.},
	pages = {1--29},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Mathur, Umang and Kini, Dileep and Viswanathan, Mahesh},
	urldate = {2023-07-09},
	date = {2018-10-24},
	langid = {english},
	file = {Mathur et al. - 2018 - What happens-after the first race enhancing the p.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\6MNVJTGW\\Mathur et al. - 2018 - What happens-after the first race enhancing the p.pdf:application/pdf},
}

@incollection{damm_parametric_2007,
	location = {Berlin, Heidelberg},
	title = {Parametric and Sliced Causality},
	volume = {4590},
	isbn = {978-3-540-73367-6},
	url = {http://link.springer.com/10.1007/978-3-540-73368-3_27},
	abstract = {Happen-before causal partial orders have been widely used in concurrent program veriÔ¨Åcation and testing. This paper presents a parametric approach to happen-before causal partial orders. Existing variants of happen-before relations can be obtained as instances of the parametric framework. A novel causal partial order, called sliced causality, is then deÔ¨Åned also as an instance of the parametric framework, which loosens the obvious but strict happen-before relation by considering static and dynamic dependence information about the program. Sliced causality has been implemented in a runtime predictive analysis tool for Java, named {jPredictor}, and the evaluation results show that sliced causality can signiÔ¨Åcantly improve the capability of concurrent veriÔ¨Åcation and testing.},
	pages = {240--253},
	booktitle = {Computer Aided Verification},
	publisher = {Springer Berlin Heidelberg},
	author = {Chen, Feng and Ro≈üu, Grigore},
	editor = {Damm, Werner and Hermanns, Holger},
	urldate = {2023-10-17},
	date = {2007},
	langid = {english},
	doi = {10.1007/978-3-540-73368-3_27},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Chen and Ro≈üu - 2007 - Parametric and Sliced Causality.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\XGFJZBMH\\Chen and Ro≈üu - 2007 - Parametric and Sliced Causality.pdf:application/pdf},
}

@inproceedings{legunsen_how_2016,
	location = {Singapore Singapore},
	title = {How good are the specs? a study of the bug-finding effectiveness of existing Java {API} specifications},
	isbn = {978-1-4503-3845-5},
	url = {https://dl.acm.org/doi/10.1145/2970276.2970356},
	doi = {10.1145/2970276.2970356},
	shorttitle = {How good are the specs?},
	abstract = {Runtime veriÔ¨Åcation can be used to Ô¨Ånd bugs early, during software development, by monitoring test executions against formal speciÔ¨Åcations (specs). The quality of runtime veriÔ¨Åcation depends on the quality of the specs. While previous research has produced many specs for the Java {API}, manually or through automatic mining, there has been no large-scale study of their bug-Ô¨Ånding eÔ¨Äectiveness.},
	eventtitle = {{ASE}'16: {ACM}/{IEEE} International Conference on Automated Software Engineering},
	pages = {602--613},
	booktitle = {Proceedings of the 31st {IEEE}/{ACM} International Conference on Automated Software Engineering},
	publisher = {{ACM}},
	author = {Legunsen, Owolabi and Hassan, Wajih Ul and Xu, Xinyue and Ro≈üu, Grigore and Marinov, Darko},
	urldate = {2023-11-06},
	date = {2016-08-25},
	langid = {english},
	file = {Legunsen et al. - 2016 - How good are the specs a study of the bug-finding.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\XSYF6GQY\\Legunsen et al. - 2016 - How good are the specs a study of the bug-finding.pdf:application/pdf},
}

@online{noauthor_rv-predict_nodate,
	title = {{RV}-Predict {\textbar} Runtime Verification Inc},
	url = {https://runtimeverification.com/predict},
	abstract = {{RV}-Predict should be used any time concurrency correctness is important to a multithreaded application. {RV}-Predict is able to efficiently detect concurrency issues and data races in programs and leverages unique predictive capabilities to detect possible races even if they do not occur in the execution trace.},
	urldate = {2023-11-07},
	langid = {english},
	file = {Snapshot:C\:\\Users\\zhyda\\Zotero\\storage\\6T7SL3BK\\predict.html:text/html},
}

@software{mathur_umangmrapid_2023,
	title = {umangm/rapid},
	rights = {{MIT}},
	url = {https://github.com/umangm/rapid},
	abstract = {Dynamic Analysis for Concurrent Programs},
	author = {Mathur, Umang},
	urldate = {2023-11-07},
	date = {2023-10-19},
	note = {original-date: 2017-12-16T02:52:56Z},
	keywords = {concurrent-programming, dynamic-analysis-engines, program-analysis, race-detection-engines, thread},
}

@incollection{katsaros_emop_2023,
	location = {Cham},
	title = {{eMOP}: A Maven Plugin for Evolution-Aware Runtime Verification},
	volume = {14245},
	isbn = {978-3-031-44266-7 978-3-031-44267-4},
	url = {https://link.springer.com/10.1007/978-3-031-44267-4_20},
	shorttitle = {{eMOP}},
	abstract = {We present {eMOP}, a tool for incremental runtime verification ({RV}) of test executions during software evolution. We previously used {RV} to find hundreds of bugs in open-source projects by monitoring passing tests against formal specifications of Java {APIs}. We also proposed evolution-aware techniques to reduce {RV}‚Äôs runtime overhead and human time to inspect specification violations. {eMOP} brings these benefits to developers in a tool that seamlessly integrates with the Maven build system. We describe {eMOP}‚Äôs design, implementation, and usage. We evaluate {eMOP} on 676 versions of 21 projects, including those from our earlier prototypes‚Äô evaluation. {eMOP} is up to 8.4√ó faster and shows up to 31.3√ó fewer violations, compared to running {RV} from scratch after each code change. {eMOP} also does not miss new violations in our evaluation, and it is open-sourced at https://github.com/{SoftEngResearch}/emop.},
	pages = {363--375},
	booktitle = {Runtime Verification},
	publisher = {Springer Nature Switzerland},
	author = {Yorihiro, Ayaka and Jiang, Pengyue and Marqu√©s, Valeria and Carleton, Benjamin and Legunsen, Owolabi},
	editor = {Katsaros, Panagiotis and Nenzi, Laura},
	urldate = {2023-11-19},
	date = {2023},
	langid = {english},
	doi = {10.1007/978-3-031-44267-4_20},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Yorihiro et al. - 2023 - eMOP A Maven Plugin for Evolution-Aware Runtime V.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\V8VC6JHD\\Yorihiro et al. - 2023 - eMOP A Maven Plugin for Evolution-Aware Runtime V.pdf:application/pdf},
}

@article{mathur_optimal_2021,
	title = {Optimal prediction of synchronization-preserving races},
	volume = {5},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3434317},
	doi = {10.1145/3434317},
	abstract = {{UMANG} {MATHUR}, University of Illinois at Urbana-Champaign, {USA} {ANDREAS} {PAVLOGIANNIS}, Aarhus University, Denmark {MAHESH} {VISWANATHAN}, University of Illinois at Urbana-Champaign, {USA} Concurrent programs are notoriously hard to write correctly, as scheduling nondeterminism introduces subtle errors that are both hard to detect and to reproduce. The most common concurrency errors are (data) races, which occur when memory-conflicting actions are executed concurrently. Consequently, considerable effort has been made towards developing efficient techniques for race detection. The most common approach is dynamic race prediction: given an observed, race-free trace ùúé of a concurrent program, the task is to decide whether events of ùúé can be correctly reordered to a trace ùúé‚àó that witnesses a race hidden in ùúé. In this work we introduce the notion of sync(hronization)-preserving races. A sync-preserving race occurs in ùúé when there is a witness ùúé‚àó in which synchronization operations (e.g., acquisition and release of locks) appear in the same order as in ùúé. This is a broad definition that strictly subsumes the famous notion of happens-before races. Our main results are as follows. First, we develop a sound and complete algorithm for predicting sync-preserving races. For moderate values of parameters like the number of threads, the algorithm runs in ùëÇ (N ) time and space, where N is the length of the trace ùúé. Second, we show that the problem has a Œ©(N /log2 N ) space lower bound, and thus our algorithm is essentially time and space optimal. Third, we show that predicting races with even just a single reversal of two sync operations is {NP}-complete and even 36 W[1]-hard when parameterized by the number of threads. Thus, sync-preservation characterizes exactly the tractability boundary of race prediction, and our algorithm is nearly optimal for the tractable side. Our experiments show that our algorithm is fast in practice, while sync-preservation characterizes races often missed by state-of-the-art methods. {CCS} Concepts: ‚Ä¢ Software and its engineering ‚Üí Software verification and validation; ‚Ä¢ Theory of computation ‚Üí Theory and algorithms for application domains; Program analysis.},
	pages = {1--29},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
	urldate = {2023-12-05},
	date = {2021-01-04},
	langid = {english},
	file = {Mathur et al. - 2021 - Optimal prediction of synchronization-preserving r.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\KDCWCU8D\\Mathur et al. - 2021 - Optimal prediction of synchronization-preserving r.pdf:application/pdf},
}

@inproceedings{serebryany_threadsanitizer_2009,
	location = {New York New York {USA}},
	title = {{ThreadSanitizer}: data race detection in practice},
	isbn = {978-1-60558-793-6},
	url = {https://dl.acm.org/doi/10.1145/1791194.1791203},
	doi = {10.1145/1791194.1791203},
	shorttitle = {{ThreadSanitizer}},
	abstract = {Data races are a particularly unpleasant kind of threading bugs. They are hard to Ô¨Ånd and reproduce ‚Äì you may not observe a bug during the entire testing cycle and will only see it in production as rare unexplainable failures. This paper presents {ThreadSanitizer} ‚Äì a dynamic detector of data races. We describe the hybrid algorithm (based on happensbefore and locksets) used in the detector. We introduce what we call dynamic annotations ‚Äì a sort of race detection {API} that allows a user to inform the detector about any tricky synchronization in the user program. Various practical aspects of using {ThreadSanitizer} for testing multithreaded C++ code at Google are also discussed.},
	eventtitle = {{WBIA} '09: Workshop on Binary Instrumentation and Applications},
	pages = {62--71},
	booktitle = {Proceedings of the Workshop on Binary Instrumentation and Applications},
	publisher = {{ACM}},
	author = {Serebryany, Konstantin and Iskhodzhanov, Timur},
	urldate = {2024-04-02},
	date = {2009-12-12},
	langid = {english},
	file = {Serebryany and Iskhodzhanov - 2009 - ThreadSanitizer data race detection in practice.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\ZNT43XD4\\Serebryany and Iskhodzhanov - 2009 - ThreadSanitizer data race detection in practice.pdf:application/pdf},
}

@inproceedings{flanagan_roadrunner_2010,
	location = {Toronto Ontario Canada},
	title = {The {RoadRunner} Dynamic Analysis Framework for Concurrent Programs},
	isbn = {978-1-4503-0082-7},
	url = {https://dl.acm.org/doi/10.1145/1806672.1806674},
	doi = {10.1145/1806672.1806674},
	abstract = {{ROADRUNNER} is a dynamic analysis framework designed to facilitate rapid prototyping and experimentation with dynamic analyses for concurrent Java programs. It provides a clean {API} for communicating an event stream to back-end analyses, where each event describes some operation of interest performed by the target program, such as accessing memory, synchronizing on a lock, forking a new thread, and so on. This {API} enables the developer to focus on the essential algorithmic issues of the dynamic analysis, rather than on orthogonal infrastructure complexities.},
	eventtitle = {{PASTE} '10: {ACM} {SIGPLAN}-{SIGSOFT} Workshop on Program Analysis for Software Tools and Engineering},
	pages = {1--8},
	booktitle = {Proceedings of the 9th {ACM} {SIGPLAN}-{SIGSOFT} workshop on Program analysis for software tools and engineering},
	publisher = {{ACM}},
	author = {Flanagan, Cormac and Freund, Stephen N.},
	urldate = {2024-04-02},
	date = {2010-05-06},
	langid = {english},
	file = {Flanagan and Freund - 2010 - The RoadRunner Dynamic Analysis Framework for Conc.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\UGA2Y23R\\Flanagan and Freund - 2010 - The RoadRunner Dynamic Analysis Framework for Conc.pdf:application/pdf},
}

@article{savage_eraser_1997,
	title = {Eraser: a dynamic data race detector for multithreaded programs},
	volume = {15},
	issn = {0734-2071},
	url = {https://dl.acm.org/doi/10.1145/265924.265927},
	doi = {10.1145/265924.265927},
	shorttitle = {Eraser},
	abstract = {Multithreaded programming is difficult and error prone. It is easy to make a mistake in synchronization that produces a data race, yet it can be extremely hard to locate this mistake during debugging. This article describes a new tool, called Eraser, for dynamically detecting data races in lock-based multithreaded programs. Eraser uses binary rewriting techniques to monitor every shared-monory reference and verify that consistent locking behavior is observed. We present several case studies, including undergraduate coursework and a multithreaded Web search engine, that demonstrate the effectiveness of this approach.},
	pages = {391--411},
	number = {4},
	journaltitle = {{ACM} Transactions on Computer Systems},
	shortjournal = {{ACM} Trans. Comput. Syst.},
	author = {Savage, Stefan and Burrows, Michael and Nelson, Greg and Sobalvarro, Patrick and Anderson, Thomas},
	urldate = {2024-04-02},
	date = {1997-11-01},
	keywords = {binary code modification, multithreaded programming, race detection},
	file = {Full Text PDF:C\:\\Users\\zhyda\\Zotero\\storage\\HZUMI3EC\\Savage et al. - 1997 - Eraser a dynamic data race detector for multithre.pdf:application/pdf},
}

@article{elmas_goldilocks_2007,
	title = {Goldilocks: a race and transaction-aware java runtime},
	volume = {42},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/1273442.1250762},
	doi = {10.1145/1273442.1250762},
	shorttitle = {Goldilocks},
	abstract = {Data races often result in unexpected and erroneous behavior. In addition to causing data corruption and leading programs to crash, the presence of data races complicates the semantics of an execution which might no longer be sequentially consistent. Motivated by these observations, we have designed and implemented a Java runtime system that monitors program executions and throws a {DataRaceException} when a data race is about to occur. Analogous to other runtime exceptions, the {DataRaceException} provides two key benefits. First, accesses causing race conditions are interruptedand handled before they cause errors that may be difficult to diagnose later. Second, if no {DataRaceException} is thrown in an execution, it is guaranteed to be sequentially consistent. This strong guarantee helps to rule out many concurrency-related possibilities as the cause of erroneous behavior. When a {DataRaceException} is caught, the operation, thread, or program causing it can be terminated gracefully. Alternatively, the {DataRaceException} can serve as a conflict-detection mechanism inoptimistic uses of concurrency. We start with the definition of data-race-free executions in the Java memory model. We generalize this definition to executions that use transactions in addition to locks and volatile variables for synchronization. We present a precise and efficient algorithm for dynamically verifying that an execution is free of data races. This algorithm generalizes the Goldilocks algorithm for data-race detectionby handling transactions and providing the ability to distinguish between read and write accesses. We have implemented our algorithm and the {DataRaceException} in the Kaffe Java Virtual Machine. We have evaluated our system on a variety of publicly available Java benchmarks and a few microbenchmarks that combine lock-based and transaction-based synchronization. Our experiments indicate that our implementation has reasonable overhead. Therefore, we believe that inaddition to being a debugging tool, the {DataRaceException} may be a viable mechanism to enforce the safety of executions of multithreaded Java programs.},
	pages = {245--255},
	number = {6},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Elmas, Tayfun and Qadeer, Shaz and Tasiran, Serdar},
	urldate = {2024-04-02},
	date = {2007-06-10},
	keywords = {data-race detection, Java runtime, runtime monitoring, software transactions},
	file = {Elmas et al. - Goldilocks A Race and Transaction-Aware Java Runt.pdf:C\:\\Users\\zhyda\\Zotero\\storage\\9IIQHNQN\\Elmas et al. - Goldilocks A Race and Transaction-Aware Java Runt.pdf:application/pdf},
}

@article{lamport_time_1978,
	title = {Time, clocks, and the ordering of events in a distributed system},
	volume = {21},
	issn = {0001-0782},
	url = {https://dl.acm.org/doi/10.1145/359545.359563},
	doi = {10.1145/359545.359563},
	abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
	pages = {558--565},
	number = {7},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Lamport, Leslie},
	urldate = {2024-04-03},
	date = {1978-07-01},
	keywords = {clock synchronization, computer networks, distributed systems, multiprocess systems},
	file = {Full Text PDF:C\:\\Users\\zhyda\\Zotero\\storage\\SPVLSNWI\\Lamport - 1978 - Time, clocks, and the ordering of events in a dist.pdf:application/pdf},
}

@online{noauthor_chapter_nodate,
	title = {Chapter¬†17.¬†Threads and Locks},
	url = {https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.4},
	urldate = {2024-04-03},
	file = {Chapter¬†17.¬†Threads and Locks:C\:\\Users\\zhyda\\Zotero\\storage\\BGN2UP6K\\jls-17.html:text/html},
}

@inproceedings{elmas_goldilocks_2006,
	location = {Berlin, Heidelberg},
	title = {Goldilocks: efficiently computing the happens-before relation using locksets},
	isbn = {978-3-540-49699-1},
	url = {https://doi.org/10.1007/11940197_13},
	doi = {10.1007/11940197_13},
	series = {{FATES}'06/{RV}'06},
	shorttitle = {Goldilocks},
	abstract = {We present a new lockset-based algorithm, Goldilocks, for precisely computing the happens-before relation and thereby detecting data-races at runtime. Dynamic race detection algorithms in the literature are based on vector clocks or locksets. Vector-clock-based algorithms precisely compute the happens-before relation but have significantly more overhead. Previous lockset-based race detection algorithms, on the other hand, are imprecise. They check adherence to a particular synchronization discipline, i.e., a sufficient condition for race freedom and may generate false race warnings. Our algorithm, like vector clocks, is precise, yet it is efficient since it is purely lockset based. We have implemented our algorithm inside the Kaffe Java Virtual Machine. Our implementation incorporates lazy evaluation of locksets and certain ‚Äúshort-circuit checks‚Äù which contribute significantly to its efficiency. Experimental results indicate that our algorithm's overhead is much less than that of the vector-clock algorithm and is very close to our implementation of the Eraser lockset algorithm.},
	pages = {193--208},
	booktitle = {Proceedings of the First combined international conference on Formal Approaches to Software Testing and Runtime Verification},
	publisher = {Springer-Verlag},
	author = {Elmas, Tayfun and Qadeer, Shaz and Tasiran, Serdar},
	urldate = {2024-04-03},
	date = {2006-08-15},
}

@online{noauthor_fasttrack_nodate,
	title = {{FastTrack}: efficient and precise dynamic race detection: {ACM} {SIGPLAN} Notices: Vol 44, No 6},
	url = {https://dl.acm.org/doi/10.1145/1543135.1542490},
	urldate = {2024-04-07},
	file = {FastTrack\: efficient and precise dynamic race detection\: ACM SIGPLAN Notices\: Vol 44, No 6:C\:\\Users\\zhyda\\Zotero\\storage\\BTNUMEZI\\1543135.html:text/html},
}

@inproceedings{kumar_efficient_2022,
	title = {Efficient Data Race Detection of Async-Finish Programs Using Vector Clocks},
	url = {http://arxiv.org/abs/2112.04352},
	doi = {10.1145/3528425.3529101},
	abstract = {Existing data race detectors for task-based programs incur significant run time and space overheads. The overheads arise because of frequent lookups in fine-grained tree data structures to check whether two accesses can happen in parallel. This work shows how to efficiently apply vector clocks for dynamic data race detection of async-finish programs with locks. Our proposed technique, {FastRacer}, builds on the {FastTrack} algorithm with per-task and per-variable optimizations to reduce the size of vector clocks. {FastRacer} exploits the structured parallelism of async-finish programs to use a coarse-grained encoding of the dynamic task inheritance relations to limit the metadata in the presence of many concurrent readers. Our evaluation shows that {FastRacer} substantially improves time and space overheads over {FastTrack}, and is competitive with the state-of-the-art data race detectors for async-finish programs with locks.},
	pages = {45--54},
	booktitle = {Proceedings of the Thirteenth International Workshop on Programming Models and Applications for Multicores and Manycores},
	author = {Kumar, Shivam and Agrawal, Anupam and Biswas, Swarnendu},
	urldate = {2024-04-07},
	date = {2022-04-02},
	eprinttype = {arxiv},
	eprint = {2112.04352 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv.org Snapshot:C\:\\Users\\zhyda\\Zotero\\storage\\MP259IXA\\2112.html:text/html;Full Text PDF:C\:\\Users\\zhyda\\Zotero\\storage\\997CQJG4\\Kumar et al. - 2022 - Efficient Data Race Detection of Async-Finish Prog.pdf:application/pdf},
}

@online{noauthor_maven_nodate,
	title = {Maven ‚Äì Welcome to Apache Maven},
	url = {https://maven.apache.org/index.html},
	urldate = {2024-04-10},
	file = {Maven ‚Äì Welcome to Apache Maven:C\:\\Users\\zhyda\\Zotero\\storage\\TCHVXECQ\\index.html:text/html},
}

@online{noauthor_maven_nodate-1,
	title = {Maven ‚Äì Guide to using Extensions},
	url = {https://maven.apache.org/guides/mini/guide-using-extensions.html},
	urldate = {2024-04-10},
	file = {Maven ‚Äì Guide to using Extensions:C\:\\Users\\zhyda\\Zotero\\storage\\YGEM8WD7\\guide-using-extensions.html:text/html},
}

@online{noauthor_maven_nodate-2,
	title = {Maven ‚Äì Available Plugins},
	url = {https://maven.apache.org/plugins/index.html},
	urldate = {2024-04-10},
	file = {Maven ‚Äì Available Plugins:C\:\\Users\\zhyda\\Zotero\\storage\\439S7D7S\\index.html:text/html},
}

@article{tillmann_parameterized_2005,
	title = {Parameterized unit tests},
	volume = {30},
	issn = {0163-5948},
	url = {https://doi.org/10.1145/1095430.1081749},
	doi = {10.1145/1095430.1081749},
	abstract = {Parameterized unit tests extend the current industry practice of using closed unit tests defined as parameterless methods. Parameterized unit tests separate two concerns: 1) They specify the external behavior of the involved methods for all test arguments. 2) Test cases can be re-obtained as traditional closed unit tests by instantiating the parameterized unit tests. Symbolic execution and constraint solving can be used to automatically choose a minimal set of inputs that exercise a parameterized unit test with respect to possible code paths of the implementation. In addition, parameterized unit tests can be used as symbolic summaries which allows symbolic execution to scale for arbitrary abstraction levels. We have developed a prototype tool which computes test cases from parameterized unit tests. We report on its first use testing parts of the .{NET} base class library.},
	pages = {253--262},
	number = {5},
	journaltitle = {{ACM} {SIGSOFT} Software Engineering Notes},
	shortjournal = {{SIGSOFT} Softw. Eng. Notes},
	author = {Tillmann, Nikolai and Schulte, Wolfram},
	urldate = {2024-04-10},
	date = {2005-09-01},
	keywords = {algebraic data types, automatic test input generation, constraint solving, symbolic execution, unit testing},
}
